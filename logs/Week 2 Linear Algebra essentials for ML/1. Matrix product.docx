Summary:
Element-wise operations (like +, -, /, *) work on vectors/matrices of the same shape, giving back an array/matrix of the same shape.
Dot product is used for:
    Two vectors of the same length → scalar result.
    Matrix × vector, or matrix × matrix (if sizes match: inner dimensions must align) → vector or matrix result.

Cross product only exists for 3D vectors (not for matrices or higher/lower dimensional arrays).
    Its result is a new 3D vector, never a scalar or a matrix.

Examples:
dot product ->    Sum of element-wise product
    u = np.array([1, 3, -2])
    v = np.array([4, -1, 5])
    dot = np.dot(u, v) # (1*4)+(3*-1)+(-2*5) = -9
    or dot = u @ v
    or np.matmul(u, v)

Matrix.Vector (dot product)
    Each row of A dotted with vector x -> vector of row results
    
    A = np.array([[1, 2, 3],
                 [4, 5, 6]])
    x = [7, 8, 9]
    dot = np.dot(A, x) # [50, 122]
    or dot = A @ x
    or np.matmul(A, x)
Matrix.Matrix
    A = np.array([[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]])
    B = np.array([[1, 2, 3],
                [2, 3, 1],
                [3, 1, 2]])
    dot = np.dot(A, B)
    or dot = A @ B
    or np.matmul(A, B) 
    print(dot) '''(
        dot[1,1] = dot product of row1 of A and column1 of B
        dot[1,2] = dot product of row1 of A and column2 of B
        dot[1,3] = dot product of row1 of A and column3 of B
        dot[2,1] = dot product of row2 of A and column1 of B
        dot[2,2] = dot product of row2 of A and column2 of B
        dot[2,3] = dot product of row2 of A and column3 of B
        dot[3,1] = dot product of row3 of A and column1 of B
        dot[3,2] = dot product of row3 of A and column2 of B
        dot[3,3] = dot product of row3 of A and column3 of B 
        )
        Output:
        [[14 11 11]
        [32 29 29]
        [50 47 47]]
    '''
Norms:
    Commonly used 4 types
    1. Euclidean (L2): np.linalg.norm(vector) # Distance from origin
        v = np.array([3, 4]), norm = np.linalg.norm(v) # output = 5 (sqrt(3**2 + 4**2))
    2. Manhattan (L1): np.linalg.norm(vector, ord=1) # Sum of absolute values
        norm = np.linalg(v, ord=1) # output = 3 + 4 = 7 (use absolute values of 3 and 4)
    3. Infinity: np.linalg.norm(vector, ord=np.inf) # Largest absolute values of the vector
        norm = np.linalg(v, ord=np.inf) # output 4
    4. Frobenius: np.linalg(matrix) # sqrt(sum of squares of all entries); matrix analog of L2
